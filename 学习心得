# FSMC工作原理详解

## 1. FSMC是什么？

**FSMC (Flexible Static Memory Controller)** 是STM32的灵活静态存储器控制器，它的作用是：
- 将STM32的内部总线扩展到外部
- 提供标准的并行总线接口
- 自动处理读写时序控制
- 将外部设备映射到STM32的地址空间

## 2. 传统方式 vs FSMC方式

### 传统GPIO方式控制LCD：
```c
// 需要手动控制每个信号
void LCD_Write_Traditional(u8 cmd, u16 data) {
    // 1. 设置数据线
    GPIOB->ODR = data;
    
    // 2. 设置DC信号(区分命令/数据)
    if(cmd) DC_LOW;  // 命令
    else DC_HIGH;    // 数据
    
    // 3. 设置CS信号
    CS_LOW;
    
    // 4. 设置WR信号
    WR_LOW;
    delay_ns(50);    // 等待建立时间
    WR_HIGH;
    
    // 5. 释放CS
    CS_HIGH;
}
```

### FSMC方式：
```c
// 直接写内存，FSMC自动处理时序
LCD_REG = 0x2C;    // 写命令，硬件自动控制所有信号
LCD_RAM = 0xF800;  // 写数据，硬件自动控制所有信号
```

## 3. FSMC如何实现自动控制？

### 地址映射机制：
```
STM32内存映射：
0x60000000 - 0x6FFFFFFF  FSMC Bank1区域

具体映射：
0x60000000 - Bank1 区域1 (NE1)
0x64000000 - Bank1 区域2 (NE2) 
0x68000000 - Bank1 区域3 (NE3)
0x6C000000 - Bank1 区域4 (NE4) ← 我们使用这个

在区域4中：
0x6C000000 - 对应A0=0 (命令寄存器)
0x6C000002 - 对应A0=1 (数据寄存器)
```

### 硬件连接对应关系：
```
STM32引脚    →    LCD引脚    →    作用
PD14-PD10    →    D0-D15     →    数据线
PF0 (A0)     →    DC/RS      →    区分命令/数据
PG12 (NE4)   →    CS         →    片选信号
PD5 (NWE)    →    WR         →    写信号
PD4 (NOE)    →    RD         →    读信号
```

## 4. 数据传输过程详解

### 写命令过程：
```c
LCD_REG = 0x2C;  // 这一行代码触发以下硬件动作：
```

**FSMC自动执行的步骤：**
1. **地址解码**：CPU访问0x6C000000地址
2. **片选激活**：NE4(PG12)拉低，激活LCD
3. **地址输出**：A0(PF0)输出0，表示写命令
4. **数据输出**：D0-D15输出0x002C
5. **写信号**：NWE(PD5)按时序拉低再拉高
6. **片选释放**：NE4(PG12)拉高，释放LCD

### 写数据过程：
```c
LCD_RAM = 0xF800;  // 这一行代码触发以下硬件动作：
```

**FSMC自动执行的步骤：**
1. **地址解码**：CPU访问0x6C000002地址
2. **片选激活**：NE4(PG12)拉低
3. **地址输出**：A0(PF0)输出1，表示写数据
4. **数据输出**：D0-D15输出0xF800
5. **写信号**：NWE(PD5)按时序拉低再拉高
6. **片选释放**：NE4(PG12)拉高

## 5. 时序控制详解

FSMC根据我们配置的时序参数自动控制信号：

```c
// 写时序配置
WriteTiming.FSMC_AddressSetupTime = 0;  // 地址建立时间
WriteTiming.FSMC_DataSetupTime = 1;     // 数据建立时间
```

**实际波形时序：**
```
时钟周期：  T1    T2    T3    T4
NE4:      ——————\____________/————————
A0:       ————————[  有效地址  ]————————
D0-D15:   ————————————[有效数据]————————
NWE:      ——————————\_______/—————————
          |<-Tasu->|<-Tds->|
```

- **Tasu**: 地址建立时间 = AddressSetupTime × HCLK周期
- **Tds**: 数据建立时间 = DataSetupTime × HCLK周期

## 6. 为什么使用FSMC的优势？

### 1. **简化编程**：
```c
// FSMC方式：一行代码
LCD_RAM = color;

// GPIO方式：需要很多行
Set_Data_Bus(color);
DC_HIGH;
CS_LOW;
WR_LOW;
delay();
WR_HIGH;
CS_HIGH;
```

### 2. **提高性能**：
- 硬件自动处理时序，速度更快
- 减少CPU指令开销
- 可配合DMA实现高速传输

### 3. **时序精确**：
- 硬件保证时序精度
- 避免软件延时的不准确性

### 4. **资源节约**：
- 不占用定时器资源
- 减少GPIO操作的CPU开销

## 7. 实际应用示例

```c
// 画一个红色矩形的完整过程
void DrawRedRectangle(void) {
    // 1. 设置显示窗口 (硬件自动处理所有时序)
    LCD_REG = 0x2A;        // 列地址命令
    LCD_RAM = 0x00;        // 起始列高字节
    LCD_RAM = 0x32;        // 起始列低字节 (50)
    LCD_RAM = 0x00;        // 结束列高字节  
    LCD_RAM = 0x96;        // 结束列低字节 (150)
    
    LCD_REG = 0x2B;        // 行地址命令
    LCD_RAM = 0x00;        // 起始行高字节
    LCD_RAM = 0x32;        // 起始行低字节 (50)
    LCD_RAM = 0x00;        // 结束行高字节
    LCD_RAM = 0x64;        // 结束行低字节 (100)
    
    LCD_REG = 0x2C;        // 写显存命令
    
    // 2. 连续写入红色数据
    for(int i = 0; i < (101*101); i++) {
        LCD_RAM = 0xF800;  // 每次写入都会自动触发完整的时序
    }
}
```

## 总结

FSMC的核心作用就是：
1. **地址映射**：将外部LCD映射到STM32地址空间
2. **时序控制**：自动生成标准的并行总线时序
3. **信号管理**：自动控制片选、读写、地址等信号
4. **简化接口**：让LCD操作变成简单的内存读写操作

这样，我们就不需要手动控制各种GPIO信号和时序，只需要像操作内存一样操作LCD！